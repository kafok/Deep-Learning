<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
		<base href="https://kafok.github.io/Deep-Learning/dogs-vs-cats/" />
        <title>Perros y Gatos</title>

        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

        <style>
            #result {
                font-weight: bold;
                font-size: 6rem;
                text-align: center;
            }
        </style>
    </head>

    <body>

        <div class="container mt-5">
            <div class="row">
                <div class="col-12 col-md-4 offset-md-4 text-center">
                    <video id="video" playsinline autoplay style="width: 1px;"></video>

                    <button class="btn btn-primary mb-2" onclick="swapCamera();">Cambiar camara</button>

                    <canvas id="canvas" width="400" height="400" style="max-width: 100%;"></canvas>
                    <canvas id="aux-canvas" width="150" height="150" style="display: none"></canvas>

                    <div id="result"></div>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>

        <script type="text/javascript">
            const size = 400;
            const video = document.getElementById('video')
            const canvas = document.getElementById('canvas')
            const auxCanvas = document.getElementById('aux-canvas')
            const ctx = canvas.getContext('2d')

            let currentStream = null
            let facingMode = 'user'

            var model = null

            ;(async () => {
                console.log('Cargando modelo...')
                model = await tf.loadLayersModel('./model.json')
                console.log('Modelo cargado')
            })();

            window.onload = function () {
                showCamera()
            }

            function showCamera() {
                const opts = {
                    audio: false,
                    video: {
                        width: size, height: size
                    }
                }

                if (navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia(opts)
                        .then(function (stream) {
                            currentStream = stream
                            video.srcObject = currentStream
                            processCamera()
                            predict()
                        })
                        .catch(function (err) {
                            alert('No se pudo utilizar la camara :(')
                            console.error(err)
                        })
                } else {
                    alert("No existe la funcion getUserMedia");
                }
            }

            function swapCamera() {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => {
                        track.stop()
                    })
                }

                facingMode = facingMode == 'user' ? 'environment' : 'user'

                const opts = {
                    audio: false,
                    video: {
                        facingMode: facingMode, width: size, height: size
                    }
                }

                navigator.mediaDevices.getUserMedia(opts)
                    .then(function (stream) {
                        currentStream = stream
                        video.srcObject = currentStream
                    })
                    .catch(function (err) {
                        console.error(err)
                        alert('Oops, hubo un error')
                    })
            }

            function processCamera() {
                ctx.drawImage(video, 0, 0, size, size, 0, 0, size, size)
                setTimeout(processCamera, 20)
            }

            function predict() {
                if (model != null) {
                    resample_single(canvas, 100, 100, auxCanvas)

                    //Hacer la predicci√≥n
                    const ctx2 = auxCanvas.getContext('2d')
                    const imgData = ctx2.getImageData(0, 0, 100, 100)

                    let arr = []
                    let arr100 = []

                    for (let p=0; p < imgData.data.length; p += 4) {
                        var red = imgData.data[p] / 255
                        var green = imgData.data[p + 1] / 255
                        var blue = imgData.data[p + 2] / 255

                        var gray = (red + green + blue) / 3

                        arr100.push([gray])
                        if (arr100.length == 100) {
                            arr.push(arr100)
                            arr100 = []
                        }
                    }

                    arr = [arr]

                    var tensor = tf.tensor4d(arr)
                    var result = model.predict(tensor).dataSync()

                    let clazz
                    if (result <= .5)
                        clazz = 'Gato'
                    else
                        clazz = 'Perro'
                        
                    document.getElementById('result').innerHTML = clazz

                }

                setTimeout(predict, 150);
            }

            /**
             * Hermite resize - fast image resize/resample using Hermite filter. 1 cpu version!
             * 
             * @param {HtmlElement} canvas
             * @param {int} width
             * @param {int} height
             * @param {boolean} resize_canvas if true, canvas will be resized. Optional.
             * Cambiado por RT, resize canvas ahora es donde se pone el chiqitillllllo
             */
            function resample_single(canvas, width, height, resize_canvas) {
                var width_source = canvas.width;
                var height_source = canvas.height;
                width = Math.round(width);
                height = Math.round(height);

                var ratio_w = width_source / width;
                var ratio_h = height_source / height;
                var ratio_w_half = Math.ceil(ratio_w / 2);
                var ratio_h_half = Math.ceil(ratio_h / 2);

                var ctx = canvas.getContext("2d");
                var ctx2 = resize_canvas.getContext("2d");
                var img = ctx.getImageData(0, 0, width_source, height_source);
                var img2 = ctx2.createImageData(width, height);
                var data = img.data;
                var data2 = img2.data;

                for (var j = 0; j < height; j++) {
                    for (var i = 0; i < width; i++) {
                        var x2 = (i + j * width) * 4;
                        var weight = 0;
                        var weights = 0;
                        var weights_alpha = 0;
                        var gx_r = 0;
                        var gx_g = 0;
                        var gx_b = 0;
                        var gx_a = 0;
                        var center_y = (j + 0.5) * ratio_h;
                        var yy_start = Math.floor(j * ratio_h);
                        var yy_stop = Math.ceil((j + 1) * ratio_h);
                        for (var yy = yy_start; yy < yy_stop; yy++) {
                            var dy = Math.abs(center_y - (yy + 0.5)) / ratio_h_half;
                            var center_x = (i + 0.5) * ratio_w;
                            var w0 = dy * dy; //pre-calc part of w
                            var xx_start = Math.floor(i * ratio_w);
                            var xx_stop = Math.ceil((i + 1) * ratio_w);
                            for (var xx = xx_start; xx < xx_stop; xx++) {
                                var dx = Math.abs(center_x - (xx + 0.5)) / ratio_w_half;
                                var w = Math.sqrt(w0 + dx * dx);
                                if (w >= 1) {
                                    //pixel too far
                                    continue;
                                }
                                //hermite filter
                                weight = 2 * w * w * w - 3 * w * w + 1;
                                var pos_x = 4 * (xx + yy * width_source);
                                //alpha
                                gx_a += weight * data[pos_x + 3];
                                weights_alpha += weight;
                                //colors
                                if (data[pos_x + 3] < 255)
                                    weight = weight * data[pos_x + 3] / 250;
                                gx_r += weight * data[pos_x];
                                gx_g += weight * data[pos_x + 1];
                                gx_b += weight * data[pos_x + 2];
                                weights += weight;
                            }
                        }
                        data2[x2] = gx_r / weights;
                        data2[x2 + 1] = gx_g / weights;
                        data2[x2 + 2] = gx_b / weights;
                        data2[x2 + 3] = gx_a / weights_alpha;
                    }
                }


                ctx2.putImageData(img2, 0, 0);
            }
        </script>
    </body>

</html>